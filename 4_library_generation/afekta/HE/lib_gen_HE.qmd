---
title: "library_generation"
format: html
---

# Introduction

The goal here is to generate *compound annotation libraries* from data of the
ring trial experiment of the HUMAN_DN.

- A table for MS1 annotation
- A mgf (or msp) file for MS2 level annotation.

Load results table curated by the labs:

```{r}
study_group <- "HE" #example HE / FE / Others
lab <- "afekta" # example: afekta / cembio / icl
library(readxl)
library(openxlsx)
res_table <- read.xlsx(file.path("3_annotation_manual", study_group,
"1_manual_curation", "fixed_lab_report", paste0("fixed_annotation_", lab, ".xlsx")))
```

ms2 data:

```{r}
library(xcms)
library(MsIO)
library(MsExperiment)

source(file.path("1_preprocessing", "setup.R"))
peak <- read.csv(file.path(
  "2_annotation_auto",
  lab, study_group,
  "peak_evidence.csv"
))
table(peak$mixture)
study_path <- file.path("1_preprocessing", lab, study_group)
mse <- readMsObject(
  XcmsExperiment(),
  AlabasterParam(path = file.path(study_path, "mse")),
  spectraPath = file.path(study_path, "mzml"))

sampleData(mse)$mixture <- sub(".*_", "", sampleData(mse)$Sample.Name)
meta <- meta[meta$Mixture %in% sampleData(mse)$mixture, ]

sampleData(mse)$mixture <- gsub("\\.", "_", sampleData(mse)$mixture)
meta$Mixture <- gsub("\\.", "_", meta$Mixture)

mse2 <- readMsObject(
  XcmsExperiment(),
  AlabasterParam(path = file.path(study_path, "mse2")),
  spectraPath = file.path(study_path, "mzml")
)
sampleData(mse2)$mixture <- sub(".*_", "", sampleData(mse2)$Sample.Name)
sampleData(mse2)$mixture <- gsub("\\.", "_", sampleData(mse2)$mixture)
```

# Generate library:

Next: filter for the one that have "ms2_count" column positive.

```{r}
fin_ms2 <- fin[fin$ms2_count > 0, ]

cpds <- fin_ms2$chrom_peak_id
```

2 injections:

```{r}
test <- automate_matching_ms2(mse2 = mse2, match_res = fin_ms2,
                              waters_data = FALSE)

fin <- fin[, c("mz", "rt", "mzmin", "mzmax", "rtmin", "rtmax",
               "target_ChEBI.name", "target_ChEBI", "target_InChIKey",
               "target_formula", "adduct", "polarity", "ms2_true_count",
               "RTI", "mixture")]

fin$ms2_true_count <- as.logical(fin$ms2_true_count)

colnames(fin) <- c("mz", "rt", "mzmin", "mzmax", "rtmin", "rtmax",
                   "compound_name", "ChEBI", "InChIKey", "formula",
                   "adduct", "polarity", "matched_to_library", "RTI",
                   "mixture")

# export
write.csv(fin, "ring_trial_library_HE.csv") ## This is moved to results/HE
```

# Exporting MS2 data

```{r}
# Example
spec1 <- split(test, test$chrom_peak_id)[[2]]
plotSpectra(spec1)
```

- We're not combining nor cleaning the selected MS2 spectra yet.
- This should be done by the lab themselves. Below we show example code how
  e.g. cleaning and combining could be performed.
- I did not get any feedback from the labs regarding this.

## Centroiding/reducing the number of fragment peaks

From the plots above it seems there are too many peaks with a similar
*m/z*. Below we zoom into a region of 1 *m/z*.

```{r}
plotSpectra(spec1[1], xlim = c(152, 153))
grid()
```

We thus next reduce the MS2 spectra grouping peaks if the difference of their
*m/z* is below 0.1 Da and reporting only one *representative* peak for each
group (using the maximum intensity and an intensity-weighted *m/z*). Note that
0.1 Da is **not** a default that should be used in every data set. It is used in
this example to show how fragment peaks could be reduced.

```{r}
spec1 <- combinePeaks(spec1, tolerance = 0.1, ppm = 0.0,
                      intensityFun = max, mzFun = mean)
```

```{r}
plotSpectra(spec1[1], xlim = c(152, 153))
grid()
```

```{r}
plotSpectra(spec1)
```


## Cleaning MS2 spectra

MS2 spectra could be cleaned based on different criteria, which might be defined
by the analyst and eventually based on the observed data. Options could be:

- remove all peaks with an *m/z* >= than the precursor (including the precursor
  peak). Note that this would only be a meaningful filter for **single charged
  ions**, because for these a fragment peak with an *m/z* larger than the
  precursor would not be possible.
- remove all fragment peaks with an intensity lower than x% from the base peak
  (i.e., highest intensity) in a spectrum.
- keep a certain number of peaks, e.g. the 10 fragments with the highest
  intensity.

As an example we plot the individual spectra indicating the position of precursor *m/z* in
each spectrum with a dashed red line.

```{r}
par(mfrow = c(2, 3))
for (i in seq_along(spec1)) {
    plotSpectra(spec1[i])
    grid()
    abline(v = precursorMz(spec1[i]), col = "#ff000060", lty = 2)
}
```

We can see that there are many fragment peaks **above** the precursor
*m/z*. We check in addition what ion/adduct the present example compound should
represent:

```{r}
fin[unique(spec1$chrom_peak_id), c("mz", "rt", "compound_name", "adduct")]
```

The expected adduct is thus a single charged ion. We therefore next remove all
peaks with a *m/z* >= the precursor *m/z*:

```{r}
a <- filterPrecursorPeaks(spec1, mz = ">=", tolerance = 0.1)
plotSpectra(a)
```


## Filtering MS2 spectra

The data set could/should be filtered to remove/exclude MS2 spectra with too few
(a single or no fragment peak) or with a too low *precursor purity* (hence
potentially representing a fragment spectrum from different ions). The precursor
purity is calculated based on the MS1 data of the spectrum acquired before the
MS2 spectrum. Thus, we need to use/read the full data set to calculate this.

Parameters `tolerance` and `ppm` should be configured based on the instrument
settings used (i.e. the *m/z* isolation window width used for MS2 ion
selection). For the present example we assume a window of +/- 0.05 Da around the
actual target m/z.

```{r}
pp <- precursorPurity(spectra(mse2), tolerance = 0.05, ppm = 0)
spectra(mse2)$precursorPurity <- pp
```

We need to re-extract the MS2 spectra in order to have this new spectra variable
available.

```{r}
test <- automate_matching_ms2(mse2 = mse2, match_res = fin_ms2,
                              waters_data = FALSE)
#' repeating the data processing
spec1 <- split(test, test$chrom_peak_id)[[2]]
spec1 <- combinePeaks(spec1, tolerance = 0.1, ppm = 0.0,
                      intensityFun = max, mzFun = mean)
```

The distribution of precursor purity for the selected MS2 spectra is shown
below.

```{r}
library(vioplot)
vioplot(test$precursorPurity)
grid()
```

More than 50% of the MS2 spectra have a purity larger 90%. We could use this
information to restrict to MS2 spectra with a high purity, or to prefer/select
MS2 spectra with a higher purity for each compound.

This could be done as shown in the example code snippet below:

```{r}
a <- spec1[spec1$precursorPurity > 0.9]
a
```

Unfortunately, not a single MS2 spectrum of the example subset would fulfill the
precursor purity criteria.

To restrict to spectra with a minimal number of fragments (5 in the example
below) the code below could be used:

```{r}
a <- spec1[lengths(spec1) >= 5]
a
```

Thus, for this example all spectra were retained.


## Combining MS2 spectra

When multiple MS2 spectra are available per feature/compound, these could be
combined into a single *representative* spectrum. Here, possible choices would
be to keep only fragment peaks present in x % of spectra (thus creating a MS2
spectrum with fewer, but *reliable* fragment peaks), or simply combine all
fragment peaks from all spectra (resulting in a more *comprehensive* MS2
spectrum).

This could be done using the `combineSpectra()` function.

## Export the data

MS2 spectra can be exported in one of the supported data types for MS2 data
sharing. Here it is important to note that these formats are **not
standardized**, thus each software uses a different *dialect* to name e.g. the
data fields.

### MGF format

```{r}
cols <- c("compound_name", "ChEBI", "InChIKey", "adduct",
          "matched_to_library", "RTI", "mixture", "formula")
peakdata <- fin[test$chrom_peak_id, cols]

mgf_exp <- cbind2(test, peakdata)
#' Define spectra variables to export
mgf_exp <- selectSpectraVariables(mgf_exp,
                                  c("spectrumId", "msLevel", "rtime",
                                    "dataOrigin", "precursorMz",
                                    "precursorIntensity", "precursorCharge",
                                    "collisionEnergy", "precursorPurity",
                                    "chrom_peak_id", "scanIndex", cols))

library(MsBackendMgf)
#' Defining the mapping/renaming of spectra variables to MGF fields
map <- spectraVariableMapping(MsBackendMgf())
#' Add additional mappings
map <- c(spectrumId = "TITLE",
         adduct = "ADDUCT",
         map)

export(mgf_exp, MsBackendMgf(), file = "std_spectra_HE.mgf",
       mapping = map)
```

### MSP format

In addition, we can also export the data in MSP format.

```{r}
msp_exp <- cbind2(test, peakdata)
msp_exp <- selectSpectraVariables(msp_exp,
                                  c("spectrumId", "msLevel", "rtime",
                                    "dataOrigin", "precursorMz",
                                    "precursorIntensity", "precursorCharge",
                                    "collisionEnergy", "precursorPurity",
                                    "chrom_peak_id", "scanIndex", cols))

library(MsBackendMsp)

map <- spectraVariableMapping(MsBackendMsp())
#' Add additional mapping/renaming of spectra variables
map <- c(InChIKey = "INCHIKEY",
         compound_name = "NAME",
         map)
export(msp_exp, MsBackendMsp(), file = "std_spectra_HE.msp",
       mapping = map)
```

# Session information

```{r}
sessionInfo()
```

