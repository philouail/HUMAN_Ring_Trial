---
title: "Generic Library Building Script"
format: html
editor: visual
---

# Library building

Comment: Separate preprocessing from library building:

-   One preprocessing pipeline per lab (for format, naming consistency, etc.)
-   One standardized library-building script that consumes the preprocessed
    files.

## Workflow explanation :

1)  Match MS1 chromatographic peaks to theoretical m/z values of potential
    ions/adducts.
2)  For each matched chromatographic peak:

-   Extract and analyze MS1 spectrum:
    -   Match isotope pattern to theoretical formula.
    -   Count and quantify adduct signals.
-   Extract MS2 spectra, and:
    -   Match to reference spectral library (e.g., GNPS).
    -   Score similarity and validate compound identity.

3)  Group peaks along RT across different adducts for each standard.
4)  Per RT region:

-   Count number of adducts.
-   Calculate MS2 coverage ratio (matched / total).

5)  Output table per compound with per-region evidence:

-   m/z match
-   isotope pattern similarity
-   number of adducts
-   MS2 match scores
-   reference match validity (true positive?)

6)  Then user can make a decision on the compound identity based on the evidence
    and the confidence level of the match.

Confidence level

| Evidence Type | Confidence | Notes |
|---------------------------|---------------------|---------------------------|
| m/z match | Low | Base assumption; needed but not sufficient |
| Isotope pattern match | Medium-Low | Confirms formula, not structure |
| Multiple ion detection | Medium | Stronger signal, especially across adducts |
| MS2 match to reference | High | Most powerful, but dependent on library coverage |
| LogP shift (optional) | Exploratory | NAPS-based RT shift logic (experimental) |

### fix this !!

```{r}
#| code-fold: true
#| code-summary: "Show the code"
library(DiagrammeR)

grViz("
digraph compound_analysis {
  graph [layout = dot, rankdir = TB]

  node [shape = box, style = filled, color = lightgray, fontname = Helvetica]

  // Step 1
  MatchMS1 [label = '1. Match Chromatographic peaks to theoretical m/z (adducts)']

  // Step 2 - MS1 Branch
  ExtractMS1 [label = '2. Extract MS1 Spectrum']
  IsotopeMatch [label = '3. Isotope pattern matching and scoring']
  CountAdducts [label = '3. Count and quantify adducts']

  // Step 2 - MS2 Branch
  ExtractMS2 [label = '2. Extract MS2 Spectrum']
  MS2LibMatch [label = '3. Match to GNPS reference library']

  // Step 3
  RTGroup [label = '4. Group peaks by RT across adducts']

  // Step 4
  RegionStats [label = '5. Calculate region stats\\n(adduct count, MS2 coverage)']

  // Step 5
  EvidenceTable [label = '6. Output table per compound\\n(m/z, isotope, adducts, MS2, validity)']

  // Step 6
  Decision [label = 'Final: User decision on compound ID\\n(based on confidence)']

  // Edges
  MatchMS1 -> ExtractMS1
  MatchMS1 -> ExtractMS2

  ExtractMS1 -> IsotopeMatch
  ExtractMS1 -> CountAdducts
  ExtractMS2 -> MS2LibMatch

  IsotopeMatch -> RTGroup
  CountAdducts -> RTGroup
  MS2LibMatch -> RTGroup

  RTGroup -> RegionStats
  RegionStats -> EvidenceTable
  EvidenceTable -> Decision
}
")

```

## set up

```{r}
lab <- ... # example hmgu ## phili: add options so everyone has the same thing
study_group <- ... #example HE
dr <- file.path("res", lab, study_group) ## adapt this


## source functions
source("library_functions.R")
```

Below I load the files that have been preprocessed. There they have
chromatographic peaks detected.

```{r}
# load the preprocessed data - to be adapted
mse_pos <- readMsObject(XcmsExperiment(), 
                  AlabasterParam(path = file.path(paste0(dr,"/objects/mse_pos"))), 
                  spectraPath = file.path("data/hmgu/HE_pos_mzml/")) #need to adapt this 

mse_neg <- readMsObject(XcmsExperiment(),
                  AlabasterParam(path = file.path(paste0(dr, "/objects/mse_neg"))), 
                  spectraPath = file.path("data/hmgu/HE_neg_mzml/")) 
```

When performing this automatically i will need to split the object and the
metadata mixture by mixture. To set up the process right now I will just do it
for one mixture.

```{r}
sp_meta <- split(meta_pos, meta_pos$filname)
# subset - will no longer be needed 
x_meta <- sp_meta[[1]]
x_mse_pos <- mse_pos[1]
x_mse_neg <- mse_neg[1]
```

We use below functionality from the *MetaboAnnotation* package to match/annotate
the identified chromatographic peaks against the expected target compounds.

## Identify chrom peaks matching ions/adducts of the standards

```{r}
#' x_mse_pos XcmsExperiment
#' x_meta data.frame with the standards expected to be present

## automatise - move function later on
# match_chrom_peaks <- function(xcms_obj, meta, adducts = c("[M+H]+", "[M+Na]+", "[M+H-H2O]+"), ppm = 10, tol = 0.05) {
#     cpks <- as.data.frame(chromPeaks(xcms_obj))
#     cpks$chrom_peak_id <- rownames(cpks)
#     #' match chrom peaks to possible ions
#     matched <- matchValues(cpks, meta, Mass2MzParam(adducts, tolerance = tol, ppm = ppm), mzColname = "mz", massColname = "M")
#     matched <- matched[whichQuery(matched)]
#     #' extract and process the results
#     res <- matchedData(matched, c("chrom_peak_id", "rtmin", "rtmax", "into", 
#                                    "target_ChEBI name", "target_ChEBI", 
#                                    "target_InChIKey", "target_formula", 
#                                    "target_M", "adduct", "score", "ppm_error")) |> 
#            as.data.frame()
#     #' Add the m/z of the adduct
#     res$adduct_mz <- mapply(res$target_M, res$adduct, FUN = mass2mz)
#     #' Calculate the chemical formula of the adduct
#     af <- mapply(res$target_formula, res$adduct, FUN = adductFormula)
#     res$adduct_formula <- gsub("^\\[|\\].*$", "", af)
#     res
# }

test <- match_chrom_peaks(x_mse_pos, x_meta, 
                          adducts = c("[M+H]+", "[M+Na]+", "[M+H-H2O]+"), 
                          ppm = 10, tol = 0.05)
test
any(duplicated(test$chrom_peak_id)) ## check for duplicates

```

## Process each chrom peak MS1 spectrum

First process the MS1 data:

-   extract full scan MS1 for each chrom peak.
-   identify all mass peaks that could be the signal of one ion/adduct of the
    compound.

```{r}
x_match_ms1 <- chromPeakSpectra(
    x_mse_pos, msLevel = 1L, peaks = x_match_res$chrom_peak_id,
    method = "closest_rt")
x_match_ms1$exactmass <- x_match_res$target_M
x_match_ms1$adduct_mz <- x_match_res$adduct_mz

x_match_ms1 <- setBackend(backend = MsBackendMemory(), object = x_match_ms1)
x_match_ms1 <- applyProcessing(x_match_ms1)

## automoatise - to be moved later 
# extract_ms1_adduct_info <- function(ms1_spectra, match_df) {
#     ms1_spectra$exactmass <- match_df$target_M
#     ms1_spectra$adduct_mz <- match_df$adduct_mz
#     ms1_spectra <- setBackend(backend = MsBackendMemory(), object = ms1_spectra)
#     
#     ## determine which other adduct peaks would be present in the MS1 spectrum.
#     adducts_detected <- spectrapply(ms1_spectra, function(z) {
#         mzs <- sort(mass2mz(z$exactmass, adductNames("positive"))[1, ])
#         z <- filterMzValues(z, mzs, ppm = 10)
#         idx <- MsCoreUtils::closest(mz(z)[[1L]], mzs)
#         z$peak_adduct_name <- list(names(mzs)[idx])
#         applyProcessing(z)
#     })
#     adducts_combined <- concatenateSpectra(adducts_detected)
# 
#     adduct_count <- lengths(adducts_combined)
#     ## In addition we add the number of adducts that have an intensity >= 0.5 the
#     ## intensity of the chrom peak's intensity
#     adduct_05 <- spectrapply(adducts_combined, function(z) {
#         adct <- match_df[z$chrom_peak_id, "adduct"]
#         idx <- which(z$peak_adduct_name[[1L]] == adct)
#         sum(intensity(z)[[1L]] >= 0.5 * intensity(z)[[1L]][idx])
#     }) |> unlist()
# 
#     match_df$ms1_adduct_count <- adduct_count
#     match_df$ms1_adduct_05_count <- adduct_05
#     list(data = match_df, spectra = adducts_combined)
# }

test_2 <- extract_ms1_adduct_info(x_match_ms1, test)
test_2$data
test_2$spectra


```

We plot these to file. An example plot is shown below.

```{r, eval=FALSE}}
#' Plot example
a <- x_match_ms1_adducts[1] # test_2$spectra[1]
cmp <- x_match_res[a$chrom_peak_id, "target_ChEBI"]
adct <- x_match_res[a$chrom_peak_id, "adduct"]

plotSpectra(a, labels = a$peak_adduct_name, labelSrt = 30,
            labelPos = 4, labelOffset = 0.1,
            main = paste(cmp, a$chrom_peak_id, adct, "RT:", rtime(a)))
#' highlight the actual adduct of the chrom peak.
idx <- which(a$peak_adduct_name[[1L]] == adct)
points(mz(a)[[1L]][idx], intensity(a)[[1L]][idx], col = "#00ceff",
       type = "h")
grid()


#' Plot all
dr <- file.path("res", "test")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
for (i in seq_along(x_match_ms1_adducts)) {
    a <- x_match_ms1_adducts[i]
    cmp <- x_match_res[a$chrom_peak_id, "target_ChEBI"]
    ## her sub ":" for "_"
    cmp <- gsub(":", "_", cmp)
    adct <- x_match_res[a$chrom_peak_id, "adduct"]
    f <- png(paste0(dr, "/", cmp, "-", a$chrom_peak_id, "-ions.png"),
             width = 8, height = 8, units = "cm", res = 600, pointsize = 4)
    plotSpectra(a, labels = a$peak_adduct_name, labelSrt = 30,
                labelPos = 4, labelOffset = 0.1,
                main = paste(cmp, a$chrom_peak_id, adct, "RT:", rtime(a)))
    idx <- which(a$peak_adduct_name[[1L]] == adct)
    points(mz(a)[[1L]][idx], intensity(a)[[1L]][idx], col = "#00ceff",
           type = "h")
    grid()
    dev.off()
}
```

For that particular example/compound, there would be an ion with a larger
intensity and hence potentially higher chance of being detected (as a
chromatographic peak) and fragmented.

We next validate for each of the identified/assigned chromatographic peaks
whether the measured isotope pattern matches the theoretical isotope pattern for
the ion (its chemical formula).

```{r}
## automatise - fails because of some concatenation.. 
# calculate_isotope_similarity <- function(ms1_spectra, match_df) {
#     library(enviPat)
#     data(isotopes)
#     #' For each MS1 spectrum, extract the peaks matching potential isotope peaks.
#     #' determine which other adduct peaks would be present in the MS1 spectrum.
#     iso_spectra <- spectrapply(ms1_spectra, function(z) {
#         idx <- isotopologues(peaksData(z)[[1L]], ppm = 20, seedMz = z$adduct_mz)
#         if (length(idx) == 1L) {
#             addProcessing(z, function(x, i = idx[[1L]], ...) x[i, , drop = FALSE]) |> 
#                 applyProcessing()
#         } else {
#             filterMzValues(z, mz = z$adduct_mz, ppm = 20, tolerance = 0) |>
#                 applyProcessing()
#         }
#     }) |>
#       concatenateSpectra() |>
#       scalePeaks()
#     #' Create theoretical isotope pattern for all chrom peaks/adducts
#     adductCharge <- function(x) MetaboCoreUtils:::.process_adduct_arg(x, "charge")
#     ip <- isopattern(
#         isotopes, check_chemform(isotopes, match_df$adduct_formula)$new_formula,
#         threshold = 0.001, charge = adductCharge(match_df$adduct), rel_to = 2
#     )
# 
#     theoretical_spectra <- isopattern_to_spectra(ip)
#     match_df$isopeak_count <- lengths(iso_spectra)
#     match_df$isopeak_sim <- diag(compareSpectra(iso_spectra, theoretical_spectra, ppm = 20))
#     match_df
#     
#     list(data = match_df, spectra = iso_spectra)
# }
# 
# #' Create a Spectra with the isotope pattern for each chemical formula.
# isopattern_to_spectra <- function(x) {
#     df <- data.frame(msLevel = 1L, formula = names(x))
#     df$mz <- lapply(x, function(z) z[, 1L])
#     df$intensity <- lapply(x, function(z) z[, 2L])
#     Spectra(df)
# }

test_3 <- calculate_isotope_similarity(test_2$spectra, test_2$data)
test_3$data
test_3$spectra
```

We next calculate the similarity between the *measured* isotope peak pattern for
each chromatographic peak and the theoretical isotope pattern calculated based
on the adduct formula. We could eventually use a different similarity
calculation method that puts more weight/importance on the similarity of the
isotope peak's intensity. In addition we create mirror plots for all pairs - one
example is shown below.

```{r, eval=FALSE}
plotSpectraMirror(x_match_ms1_isopeaks[4],
                  ms1_theoretical_isopeaks[4], ppm = 20,
                  main = paste(x_match_res$target_ChEBI[4],
                               x_match_res$chrom_peak_id[4],
                               x_match_res$adduct[4]))

#' Add isotope similarity information
x_match_res$isopeak_count <- lengths(x_match_ms1_isopeaks)
x_match_res$isopeak_sim <- diag(
    compareSpectra(x_match_ms1_isopeaks, ms1_theoretical_isopeaks, ppm = 20))

for (i in seq_along(x_match_ms1_isopeaks)) {
    f <- png(paste0(dr, "/", x_match_res$target_ChEBI[i], "-",
                    x_match_res$chrom_peak_id[i], "-isotope-pattern.png"),
             width = 8, height = 8, units = "cm", res = 600, pointsize = 4)
    plotSpectraMirror(x_match_ms1_isopeaks[i],
                      ms1_theoretical_isopeaks[i], ppm = 20,
                      main = paste(x_match_res$target_ChEBI[i],
                                   x_match_res$chrom_peak_id[i],
                                   x_match_res$adduct[i]))
    grid()
    dev.off()

}
```

**Isotopes**: comparing the observed against the theoretical isotope pattern for
a chrom peak (or feature) to compound assignment could provide additional
evidence for the match. The isotope pattern would base exclusively by the
chemical formula and could be easily calculated with the *enviPat* R package.
Note however, that this would **not** help with isomers (i.e. different
compounds with same m/z eluting at different time) as their chemical formula is
expected to be the same. Also, isotope peaks are expected to be detected only
for high intensity signals, as the signal might be below detection limits
otherwise.

## Process each chrompeaks MS2 annotation

We use a rather loose value for parameter `expandMz` in the selection of
fragment spectra for each chromatographic peak as we don't expect any
additional/other ion being present close to the standard's tentative
chromatographic peak.

```{r}
ms2peaks <- chromPeakSpectra(x_mse_pos, method = "all", 
                             expandRt = 2, expandMz = 0.01, 
                             peaks = rownames(x_match_res) ,
                             chromPeakColumns = c("rt", "mz", "mzmin",
                                                  "mzmax", "rtmin", "rtmax",
                                                  "into")) 

## here could also filter to only keep the M+H+ ions as ref library mostly have 
## that

## append number of MS2 to the result table
cnts <- table(ms2peaks$chrom_peak_id)
x_match_res[names(cnts), "ms2_count"] <- as.integer(cnts)

## clean ms2. 
#' Remove low intensity peaks; this is 5% of max intensitity. too restrictive?
low_int <- function(x, ...) {
    x > max(x, na.rm = TRUE) * 0.05
}
# full ms2 data 
ms2peaks <- filterIntensity(ms2peaks, intensity = low_int)
#' Remove precursor peaks and restrict to spectra with a minimum
#' number of peaks
ms2peaks <- filterPrecursorPeaks(ms2peaks, ppm = 50, mz = ">=")
ms2peaks <- ms2peaks[lengths(ms2peaks) > 1] |>
    scalePeaks()

ms2peaks <- setBackend(backend = MsBackendMemory(), object = ms2peaks)
ms2peaks <- applyProcessing(ms2peaks)
```

Apply the same to the ref database.

```{r}
library(RSQLite)
library(MsBackendSql)
dbfile <- "MsBackendSql.GNPS.matchms.cleaned.v1.sqlite"
con <- dbConnect(SQLite(), dbfile)
ms2_ref <- Spectra(con, source = MsBackendSql())
ms2_ref <- ms2_ref[ms2_ref$polarity == 1]

#' Same spectra processing as with the experimental data
ms2_ref <- filterIntensity(ms2_ref, intensity = low_int) |>
    filterPrecursorPeaks(ppm = 50, mz = ">=")

ms2_ref <- ms2_ref[lengths(ms2_ref) > 1] |>
     scalePeaks()

ms2_ref <- setBackend(backend = MsBackendMemory(), object = ms2_ref)
ms2_ref <- applyProcessing(ms2_ref)
```

Quick overview on the filtered references database.

```{r}
length(ms2_ref)

length(unique(ms2_ref$inchikey))
```

We have thus only reference spectra for a relatively low number of compounds.
What's even more surprising is that, although we filtered above for positive
polarity spectra, negatively charged adduct definitions are reported:

```{r}
sort(table(ms2_ref$adduct), decreasing = TRUE)

#' Is there any issue with either the reported polarity or adduct information?
```

We however proceed for now with this reference database. We use rather relaxed
m/z similarity settings accounting for potential uncalibrated or low resolution
spectra.

```{r}
prm <- CompareSpectraParam(ppm = 40, tolerance = 0.05,
                           requirePrecursor = TRUE,
                           THRESHFUN = function(x) which(x >= 0.6))

ms2peaks_mtch <- matchSpectra(ms2peaks, ms2_ref, param = prm)
ms2peaks_mtch

ms2_mtch <- ms2peaks_mtch[whichQuery(ms2peaks_mtch)]

df <- matchedData(ms2_mtch)[, c("chrom_peak_id", "target_compound_name",
                                "target_inchikey", "score", 
                                ".original_query_index", "target_adduct")]
df$target_index <- targetIndex(ms2_mtch)
df$query_index <- queryIndex(ms2_mtch)
#' Report for each chrom peak <-> compound combination the highest matching
#' pair
df <-
    df |>
    as.data.frame() |>
    split(f = paste(df$chrom_peak_id, df$target_inchikey)) |>
    lapply(function(z) {
        z[which.max(z$score), ]
    }) |>
    do.call(what = rbind.data.frame)
rownames(df) <- NULL
pandoc.table(df,
             style = "rmarkdown",
             split.table = Inf)

#' append number of spectra that have at least one match. 
#' need to use the columns .original_query_index and chrom_peak_id
try <- df[!duplicated(df$.original_query_index), ]
tmp <- table(try$chrom_peak_id) # works also if chrom_peak_id is not ordered
x_match_res[names(tmp), "ms2_matched_count"] <- as.integer(tmp)

## now need to check using inchiKey if it's a TRUE positive identification
## onlly match first partt of inchikey, using sub("-.*", "", x)
true <- df[sub("-.*", "", df$target_inchikey) %in% sub("-.*", "", x_meta$InChIKey), ]
## add standnard name 
true <- merge(true, x_match_res[, c("target_ChEBI.name", "chrom_peak_id")],
              by = "chrom_peak_id")
x_match_res[unique(true$chrom_peak_id), "ms2_true_count"] <- table(true$chrom_peak_id)

## automatise - need to fix 
match_ms2_to_library <- function(ms2_spectra, ref_spectra, meta_df, min_score = 0.6) {
    prm <- CompareSpectraParam(
        ppm = 40, tolerance = 0.05,
        requirePrecursor = TRUE,
        THRESHFUN = function(x) which(x >= min_score)
    )
    matches <- matchSpectra(ms2_spectra, ref_spectra, param = prm)
    mtch <- matches[whichQuery(matches)]

    df <- matchedData(mtch)[, c("target_compound_name", "target_inchikey",
                                "score", "chrom_peak_id", ".original_query_index")]
    df$target_index <- targetIndex(mtch)
    df$query_index <- queryIndex(mtch)
    df <- df |>
        split(f = paste(df$chrom_peak_id, df$target_inchikey)) |>
        lapply(function(z) z[which.max(z$score), ]) |> 
        do.call(rbind, .) |> as.data.frame()

    ## Count number of MS2 spectra per chrom peak with match
    match_summary <- df[!duplicated(df$.original_query_index), ]
    match_table <- table(match_summary$chrom_peak_id)

    ## TRUE positive: inchikey match with known standard
    match_summary$short_inchikey <- sub("-.*", "", match_summary$target_inchikey)
    meta_keys <- sub("-.*", "", meta_df$InChIKey)
    true_matches <- match_summary[match_summary$short_inchikey %in% meta_keys, ]

    list(all_matches = df, true_matches = true_matches, match_table = match_table)
}

```

```{r, eval=FALSE}
## plot 
i <- true$.original_query_index[1]
j <- true$target_index[1]
query_ms2 <- query(ms2_mtch)[i]
target_ms2 <- target(ms2_mtch)[j]

plotSpectraMirror(query_ms2, target_ms2, main = true$target_ChEBI.name[1])

for (i in seq_len(nrow(true))) {
    f <- png(paste0(dr, "/", true$target_ChEBI.name[i], "-",
                    true$chrom_peak_id[i], "-ms2.png"),
             width = 8, height = 8, units = "cm", res = 600, pointsize = 4)
    query_ms2 <- query(ms2_mtch)[true$query_index[i]]
    target_ms2 <- target(ms2_mtch)[true$target_index[i]]
    plotSpectraMirror(query_ms2, target_ms2,
                      main = paste(true$target_ChEBI.name[i],
                                   true$chrom_peak_id[i]))
    grid()
    dev.off()
}
```

Ok so there are probably more things to do but pretty nice for now. Also GNPS
has some adducts info. Would be nice to quickly check that.

## RT grouping

For each standard: - group identified/assigned chrom peaks into *RT regions*.
This should put adduct chrom peaks into the same group.

Now we would go through each standards. and create regions info/concatenate
results based on RT regions.

```{r}
library(MsFeatures)
## below we group based on RT
sp_res <- split(x_match_res, x_match_res$target_ChEBI.name)
x_match_res <- lapply(sp_res, function(z) {
    rts  <- chromPeaks(x_mse_pos)[z$chrom_peak_id, "rt"]
    param <- SimilarRtimeParam(diffRt = 10, groupFun = groupClosest)
    groups <- groupFeatures(rts, param)
    z$rt <- rts
    z$rt_regions <- as.numeric(groups)
    z
}) |> 
    do.call(what = rbind.data.frame)
```

I would export that as a single peak evidence file

```{r}
write.csv(x_match_res, 
          file = "res/hmgu/peak_evidence.csv", row.names = FALSE)
```

oki now grouped we can work/summarize "per standard"

```{r}
## concatenate below 
## - need to go through each group, add number of peaks, concatenate peakId, 
## and all the results per peaks.
##  - do we have anything that is not quantified beside the peaks id ?
##  rt_region 
##  the columns starting with "target-" are identical for compound of the same standard 
##  rtmin: take the min 
##  rtmax: take the max
##  rt: report also the median absolute deviation of the rt's per group (`mad(x_res$rt)`)
##  adduct, chrompeak_id: concatenate with |
##  into: average - or report the max?
##  ms1_adduct_count: add 
##  ms1_adduct_05_count: add
##  isopeak_count: add
##  isopeak_sim: average
##  ms2_count: add
##  ms2_matched_count: add
##  ms2_true_count: add
## test on x_res 


## comments: 
## Maybe we could just summaries the MS2 matching by TRUE/FALSE whether we 
## have a true positive identification ?
split(x_res, x_res$rt_region) |>
    lapply(function(z) {
        idx_rmv <- colnames(z) %in% c("adduct_formula", "adduct_mz", "score", "ppm_error")
        res <- z[1, !idx_rmv]
        res$chrom_peak_id <- paste(z$chrom_peak_id, collapse = "|")
        res$adduct <- paste(z$adduct, collapse = "|")
        res$rtmin <- min(z$rtmin)
        res$rtmax <- max(z$rtmax)
        res$into <- mean(z$into)
        res$ms1_adduct_count <- sum(z$ms1_adduct_count)
        res$ms1_adduct_05_count <- sum(z$ms1_adduct_05_count)
        res$isopeak_count <- sum(z$isopeak_count)
        res$isopeak_sim <- mean(z$isopeak_sim)
        res$ms2_count <- sum(z$ms2_count)
        res$ms2_matched_count <- sum(z$ms2_matched_count)
        res$ms2_true_count <- sum(z$ms2_true_count)
        res$number_of_peaks <- nrow(z)
        res
    }) |>
    do.call(what = rbind) |>
    as.data.frame()
```

Save below for rt region results

```{r}
write.csv(x_match_res, 
          file = "res/hmgu/peak_evidence_rt_grouped.csv", row.names = FALSE)
```

Plotting should then be down below per standard/regions to faciliate the
interpretation.

```{r, eval=FALSE}
## plots ## - plot the EICs for each standard, with the RT regions.
eic <- chromPeakChromatograms(x_mse_pos, 
                              peaks = x_match_res$chrom_peak_id[idx], 
                              expandRt = 10, 
                              expandMz =0.02)
fData(eic)$adduct <- x_match_res$adduct[idx]
plot(eic) ## i'd like to plot with the adduct as a subtitle but i'm struggling. 

## reorganise the one aboves and create separate function 
```

Next to implement:

-   position of peak compared to NAPS peaks

    -   Preprocess NAPS data/identifies peaks
    -   have a column NAPS_left and NAPS_right with the NAPS peaks ID

-   peak shape correlation score between peaks of same regions. This is were we
    test the peak shape correlation that Anna tested using artificial data.

-   Integrate neg results
