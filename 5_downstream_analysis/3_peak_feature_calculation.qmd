---
title: "Peak Feature Calculation"
format: html
execute:
  dir: project
---

### TODO

- Introduce statistical test for the differences observed.
- introduce the setups used by each lab and relate to the observed differences.

# Introduction

This document performs peak feature calculation and analysis on the extracted
ion chromatograms (EICs). The analysis includes:

1. EIC extraction and preprocessing (baseline correction, smoothing, peak isolation)
2. Peak feature calculation (metrics like FWHM, entropy, tailing factor, etc.)
3. Inter-lab comparison of peak features
4. Retention time stability analysis
5. Quantitative robustness assessment
6. PCA on peak features

## Load libraries

```{r library, include=TRUE, warning=FALSE, message=FALSE}
library(Chromatograms)
library(Spectra)
library(xcms)
library(MsIO)
library(MsExperiment)
library(tidyr)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(rstatix)
library(stringr)
library(janitor)
library(pheatmap)

base_path <- file.path("5_downstream_analysis")
source(file.path(base_path,"rt_analysis_function.R"))
```

# Load Data

Load the TIC full spectra and annotation data:

```{r load-tic-full-spectra}
load(file.path(base_path, "object/tic_full_spectra.RData"))
```


```{r load-annotations}
study_group <- "HE"
res_afekta <- read.csv(file.path("4_library_generation", "afekta",
                                 study_group, "ring_trial_library_HE.csv"))
res_hmgu <- read.csv(file.path("4_library_generation", "hmgu",
                               study_group, "ring_trial_library_HE.csv"))
res_icl <- read.csv(file.path("4_library_generation", "icl",
                               study_group, "ring_trial_library_HE.csv"))
res_cembio <- read.csv(file.path("4_library_generation", "cembio",
                                 study_group, "ring_trial_library_HE.csv"))
```

# Prepare Peak Table

Create a peak table from the annotations with padding for EIC extraction:

```{r peak-table}
res_afekta$lab <- "afekta"
res_hmgu$lab <- "hmgu"
res_icl$lab <- "icl"
res_cembio$lab <- "cembio"

peak_table <- rbind(res_hmgu, res_afekta, res_icl, res_cembio)

colnames(peak_table)[3:6] <- c("mzMin", "mzMax", "rtMin", "rtMax")
peak_table$mzMin <- peak_table$mzMin - 0.003
peak_table$mzMax <- peak_table$mzMax + 0.003
peak_table$rtMin <- peak_table$rtMin - 3
peak_table$rtMax <- peak_table$rtMax + 3
peak_table$polarity <- ifelse(peak_table$polarity == "pos", 1, 0)
```

Summary of peak table:

```{r peak-summary}
## number of peak per lab
table(peak_table$lab)

## number of compound per lab
split(peak_table$compound_name, peak_table$lab) |>
  lapply(unique) |>
  lapply(length)
```

# Extract EICs

Extract ion chromatograms for detected peaks:

```{r load-eics-detected, warning = FALSE}
load(file.path(base_path, "object/eics_detected.RData"))
## impute.
eics <- imputePeaksData(eics, method = "linear") ## this should be done already, remove when the whole thing is fixed.
eics <- applyProcessing(eics)
```

Summary of EIC lengths:

```{r peak-lengths}
split(lengths(eics), eics$lab) |>
  lapply(summary)
```

# Clean EICs

Apply baseline correction, smoothing, and peak isolation:

```{r clean-eics}
baseline <- BaselineParam(lambda = 200, p = 0.005)
smooth_params <- SavitzkyGolayParam(window = 9, polynomial = 2)
isolate_params <- IsolatePeakParam(frac = 0.05, tail_point = 1)

final_eics <- eics |>
  processEICs(param = baseline) |> ## there's a problem, the object should be imputed but is not. DEFINITELY need to recreate the objects.
  processEICs(param = smooth_params) |>
  processEICs(param = isolate_params)

## get rid of empty eics (from isolation or bad extraction)
idx_na <- which(sapply(intensity(final_eics), function(i) all(is.na(i))) |
                  lengths(intensity(final_eics)) < 3)

if (length(idx_na) > 0) {
  print(paste("Removing", length(idx_na), "EICs with all NA intensities or too short"))
  final_eics <- final_eics[-idx_na]
}
```

# Calculate Peak Metrics

```{r calculate-metrics}
# Calculate metrics using custom function
metrics <- calculatePeakMetrics(peaksData(final_eics))

# Merge metrics with EIC metadata (lab, mixture, compound)
eic_data <- as.data.frame(chromData(final_eics))
full_peak_report <- cbind(eic_data, metrics)

# Filter out low-intensity peaks
idx_low_int <- which(full_peak_report$apex_intensity < 500)
if (length(idx_low_int) > 0) {
  warning(paste("Removing", length(idx_low_int), "peaks with apex intensity < 500"))
  full_peak_report <- full_peak_report[-idx_low_int, ]
}

head(full_peak_report)
```

Save the peak report for later use:

```{r save-peak-report}
save(full_peak_report, file = file.path(base_path, "object/full_peak_report.RData"))
write.csv(full_peak_report, file = file.path(base_path, "object/full_peak_report.csv"), row.names = FALSE)
save(final_eics, file = file.path(base_path, "object/final_eics.RData"))
```

In this report, we analyze the calculated peak features across different labs and setups.
and how they relate to hardware differences.

## 2.2 Load and Clean Lab Setup Metadata

We parse the lab_setup_phase1.csv to link differences to hardware.

```{r load-metadata}
# Read raw CSV
lab_meta_raw <- read.csv(
  file.path(base_path, "lab_setup_phase1.csv"),
  header = FALSE,
  stringsAsFactors = FALSE
)

# The CSV has a dual header structure. Row 2 contains the actual column names.
colnames(lab_meta_raw) <- lab_meta_raw[2, ]
lab_meta <- lab_meta_raw[-c(1, 2), ] %>%
  clean_names() %>%
  rename(lab_id = 1) %>% # Assuming first column is the Lab identifier
  filter(lab_id != "") # Remove empty rows

# Clean up specific columns for plotting
lab_meta <- lab_meta %>%
  mutate(
    lc_instrument_clean = str_extract(lc_instrument, "^[A-Za-z]+"), # Extract Brand (Agilent, Waters, etc)
    ms_instrument_clean = str_extract(ms_instrument, "^[A-Za-z]+"),
    column_brand = str_extract(column, "^[A-Za-z]+")
  )


# subset for current method: hamornized (in column "details")
lab_meta <- lab_meta %>%
  filter(details == "harmonized")

# Display the parsed setup
head(lab_meta)


full_peak_report_meta <- full_peak_report %>%
  left_join(lab_meta, by = c("lab" = "lab_id")) #breaks here

head(full_peak_report_meta)
```


# Peak Feature Summary by Lab

Explore peak metrics across labs to understand differences in chromatographic
and MS performance.

## Entropy

Entropy is a measure of peak complexity or "purity".

- Low entropy: "pure," sharp, simple peak shape (signal highly concentrated)
- High entropy: "messy" peak that is broad, noisy, or has tailing/fronting

```{r entropy-summary}
split(full_peak_report$entropy, full_peak_report$lab) |>
  lapply(summary)
```

## FWHM (Full Width at Half Maximum)

FWHM is the classic measure of peak width.

- Low FWHM: sharp, narrow peaks (high chromatographic efficiency)
- High FWHM: broad peaks (poorer resolution, more co-elution)

```{r fwhm-summary}
split(full_peak_report$fwhm, full_peak_report$lab) |>
  lapply(summary)
```

## Gaussian Similarity

Measures how well the peak fits a Gaussian shape (R²).

- High R²: ideal Gaussian peak shape
- Low R²: deviations from ideal shape (tailing, fronting, etc.)

```{r gaussian-summary}
split(full_peak_report$gaussian_similarity, full_peak_report$lab) |>
  lapply(summary)
```

## Tailing Factor

Tailing Factor measures peak symmetry.

- Close to 1: symmetric peak (ideal)
- Greater than 1: peak tailing (undesirable)
- Less than 1: peak fronting (undesirable)

```{r tailing-summary}
split(full_peak_report$tailing_factor, full_peak_report$lab) |>
  lapply(summary)
```

# Downstream Peak Feature Analysis

## 1. Retention Time (RT) Stability

Calculate the mean, SD, and CV of retention time for each compound across labs.

- Low CV: good chromatographic stability and inter-lab agreement
- High CV: significant RT shifts, compound sensitive to LC setup differences

```{r rt-stability}
rt_report <- full_peak_report |>
  group_by(compound_name, mixture) |>
  summarize(
    mean_rt = mean(rt_apex, na.rm = TRUE),
    sd_rt = sd(rt_apex, na.rm = TRUE),
    cv_rt = sd_rt / mean_rt,
    n_detect = n(),
    .groups = "drop"
  ) |>
  arrange(desc(cv_rt))

print("Retention Time Stability Report (Top 10 most variable):")
head(rt_report, 10)

# Plot the distribution of RT CVs
ggplot(rt_report, aes(x = cv_rt)) +
  geom_histogram(bins = 30, fill = "steelblue", alpha = 0.8) +
  labs(
    title = "Distribution of Retention Time CVs",
    x = "CV of RT (per compound)",
    y = "Frequency"
  ) +
  theme_minimal()
```

## 2. EIC Intensity Consistency (Quantitative Robustness)

Since the LC setup is harmonized and the same standard mixture is used,
differences in measured peak area/height are due to variations in MS
(ionization efficiency, instrument tuning, mass accuracy/resolution, MS type).

- Low CV: good quantitative agreement across labs
- High CV: large differences in MS sensitivity for that compound

```{r intensity-consistency}
intensity_report <- full_peak_report |>
  group_by(compound_name, mixture) |>
  summarize(
    mean_auc = mean(auc, na.rm = TRUE),
    sd_auc = sd(auc, na.rm = TRUE),
    cv_auc = sd_auc / mean_auc,
    mean_height = mean(apex_intensity, na.rm = TRUE),
    sd_height = sd(apex_intensity, na.rm = TRUE),
    cv_height = sd_height / mean_height,
    n_detect = n(),
    .groups = "drop"
  ) |>
  arrange(desc(cv_auc))

print("Quantitative Robustness Report (Top 10 most variable by Area):")
head(intensity_report, 10)

# Plot the distribution of Area CVs
ggplot(intensity_report, aes(x = cv_auc)) +
  geom_histogram(bins = 30, fill = "darkred", alpha = 0.8) +
  labs(
    title = "Distribution of Peak Area (AUC) CVs",
    x = "CV of AUC (per compound)",
    y = "Frequency"
  ) +
  theme_minimal()
```

## 3. Inter-Lab Statistical Comparison

We use the Kruskal-Wallis test (non-parametric ANOVA) to determine if peak features differ significantly between labs, followed by comparisons of distributions.

### 3.1 Peak Width (FWHM) Analysis

Are the peaks significantly sharper in some labs?

```{r fwhm-analysis}
# 1. Visualization
p1 <- ggviolin(full_peak_report_meta, x = "lab", y = "fwhm", fill = "lab",
         add = "boxplot", add.params = list(fill = "white")) +
  geom_hline(yintercept = median(full_peak_report_meta$fwhm), linetype = 2) +
  labs(title = "Peak Width (FWHM) Distribution by Lab",
       y = "FWHM (seconds)", x = "Laboratory") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")

print(p1)

# 2. Statistical Test
# Kruskal-Wallis test
kw_res <- full_peak_report_meta %>% kruskal_test(fwhm ~ lab)
print(kw_res)

# 3. Effect Size (epsilon squared)
# 0.01-0.06 (small), 0.06-0.14 (moderate), >= 0.14 (large)
eff_res <- full_peak_report_meta %>% kruskal_effsize(fwhm ~ lab)
print(eff_res)
```

### 3.2 Tailing Factor Analysis

Do certain labs produce more symmetrical peaks?

```{r tailing-analysis}
p2 <- ggviolin(full_peak_report_meta, x = "lab", y = "tailing_factor", fill = "lab",
         add = "boxplot", add.params = list(fill = "white")) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "red") + # Ideal symmetry
  labs(title = "Tailing Factor by Lab",
       subtitle = "Closer to 1.0 is better",
       y = "Tailing Factor", x = "Laboratory") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")

print(p2)
```

## 4. Hardware Impact Analysis

This section relates the observed differences to the setup metadata.

### 4.1 Does LC Instrument Brand affect Peak Width?

```{r lc-impact}
# Filter out NAs in instrument data
plot_data <- full_peak_report_meta %>%
  filter(!is.na(lc_instrument_clean))

ggplot(plot_data, aes(x = lc_instrument_clean, y = fwhm, fill = lc_instrument_clean)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Impact of LC Instrument on Peak Width",
       x = "LC System Manufacturer",
       y = "FWHM (s)") +
  theme_minimal() +
  scale_fill_brewer(palette = "Pastel1")
```


## 5. PCA of Peak Features

We perform PCA to see if peaks cluster by Lab, Instrument, or Mixture.

```{r pca-analysis}
# Select numeric features for PCA
pca_cols <- c("fwhm", "tailing_factor", "asymmetry", "entropy", "auc", "apex_intensity")
pca_input <- full_peak_report_meta[, pca_cols]

# Log transform area/intensity to handle dynamic range
pca_input$auc <- log10(pca_input$auc + 1)
pca_input$apex_intensity <- log10(pca_input$apex_intensity + 1)
pca_input <- na.omit(pca_input)

# Run PCA
pca_res <- prcomp(pca_input, center = TRUE, scale. = TRUE)

# Prepare plotting data
pca_scores <- as.data.frame(pca_res$x)
pca_scores$lab <- full_peak_report_meta$lab[rownames(pca_input) %in% rownames(pca_scores)]
pca_scores$lc_type <- full_peak_report_meta$lc_instrument_clean[rownames(pca_input) %in% rownames(pca_scores)]
pca_scores$mixture <- full_peak_report_meta$mixture[rownames(pca_input) %in% rownames(pca_scores)]

# Variance explained
var_expl <- summary(pca_res)$importance[2, 1:2] * 100

# Plot 1: Colored by Laboratory
g1 <- ggplot(pca_scores, aes(x = PC1, y = PC2, color = lab)) +
  geom_point(alpha = 0.7, size = 2) +
  labs(title = "PCA: Colored by Lab",
       x = sprintf("PC1 (%.1f%%)", var_expl[1]),
       y = sprintf("PC2 (%.1f%%)", var_expl[2])) +
  theme_bw()

# Plot 2: Colored by LC Instrument (Hardware Effect)
g2 <- ggplot(pca_scores, aes(x = PC1, y = PC2, color = lc_type)) +
  geom_point(alpha = 0.7, size = 2) +
  labs(title = "PCA: Colored by LC System",
       x = sprintf("PC1 (%.1f%%)", var_expl[1]),
       y = sprintf("PC2 (%.1f%%)", var_expl[2]),
       color = "LC System") +
  theme_bw()

# Arrange side by side
ggarrange(g1, g2, ncol = 2, common.legend = FALSE)
```

## 6. Conclusions

Peak feature analysis complete. Key metrics calculated:

- Entropy (peak purity)
- FWHM (peak width)
- Gaussian similarity (peak shape quality)
- Tailing factor (peak symmetry)
- Retention time stability
- Quantitative robustness (peak area/height CVs)

Results saved to `object/full_peak_report.RData` for downstream analysis.

Based on the analysis above:

- **Lab Variability**: The Kruskal-Wallis test (p = `r format.pval(kw_res$p, digits=3)`) indicates whether there are significant differences in peak widths between labs.
- **Hardware Influence**: Visualizations in Section 5 suggest that specific LC systems (e.g., `r names(sort(table(full_peak_report_meta$lc_instrument_clean), decreasing=T)[1])`) may contribute to observed variations in peak shapes.
- **Clustering**: PCA reveals if these features drive systematic clustering, helping identify outliers or method deviations.
