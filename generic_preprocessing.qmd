---
title: "generic_preprocessing"
format: html
editor: visual
---

# Setup & Raw Data Investigation

This document provides a *generic preprocessing pipeline* using the HMGU
reference method for both positive and negative modes.

> To use this: change the `lab` variable below to point to your dataset folder,
> and ensure the file paths conform to the expected structure. Check the
> comments through the document for more details and to see what needs to be
> adapted to your dataset.

## Load Required Packages

```{r, message=FALSE, warning=FALSE}
library(readxl)
library(S4Vectors)
library(MsExperiment)
library(xcms)
library(Spectra)
library(Biobase)
library(pheatmap)
library(alabaster.base)
library(MsIO)
library(RColorBrewer)
library(MetaboCoreUtils)
library(MetaboAnnotation)
```

## Load metadata and raw files

```{r}
lab <- "your_lab_folder"  # <<<--- CHANGE THIS to your lab name

```

```{r, warning=FALSE, message=FALSE}
meta_pos <- read_xlsx(paste0("data/", lab, "/RefMethod_HE.xlsx"), 
                      sheet = 2L, skip = 1, .name_repair = "minimal") |>
    as.data.frame(check.names = FALSE)
files_name <- unique(meta_pos$filname)

```

```{r, warning=FALSE, message=FALSE, eval=FALSE}
seq_pos <- read_xlsx(paste0("data/", lab, "/HE_pos_mzml/seq.xlsx")) |> 
    transform(polarity = "pos")
seq_neg <- read_xlsx(paste0("data/", lab, "/HE_neg_mzml/seq.xlsx")) |> 
    transform(polarity = "neg")
seq <- rbind(seq_pos, seq_neg)
seq$filename <- paste0(seq$`Data File`, ".mzML")

mse <- readMsExperiment(paste0("data/", lab,"/HE_mzml/", seq$filename), seq)
```

Below we set up the parallel processing, which will allow to make the
pre-processing MUCH more efficient. please adjust to the number of cores that
your computer can handle (mine has 4 so I use 2 or 3 for data analysis)

This number will then be the same as the one oyu input in the `chunkSize =`
parameter in the preprocessing steps.

```{r}
cores_nb <- ... # Adjust the number of cores based on your machine
if (.Platform$OS.type == "unix") {
    register(MulticoreParam(cores_nb))
} else {
    register(SnowParam(cores_nb))
}
```

## Overview and Quality

Split pos and neg for this part.

```{r}
mse_pos <- mse[sampleData(mse)$polarity == "pos"]
mse_neg <- mse[sampleData(mse)$polarity == "neg"]
```

Suggestion to extract the BPC of all samples and plot them, all in one. BPC

```{r, eval=FALSE}
#| fig-height: 8
#| fig-width: 6
col_sample_type <- brewer.pal(
    n = max(3, length(unique(sampleData(mse_pos)$sample_type))), "Set2")
names(col_sample_type)[seq_along(unique(sampleData(mse_pos)$sample_type))] <-
    unique(sampleData(mse_pos)$sample_type)
bpc_pos <- chromatogram(mse_pos, aggregationFun = "max")
bpc_neg <- chromatogram(mse_neg, aggregationFun = "max")

xl <- range(unlist(lapply(bpc_pos, rtime)), unlist(lapply(bpc_neg, rtime)))
yl <- max(unlist(lapply(bpc_pos, intensity)),
          unlist(lapply(bpc_neg, intensity)), na.rm = TRUE)
plot(3, 3, pch = NA, xlim = xl, ylim = c(-yl, yl), xlab = "rtime",
     ylab = "intensity", main = "BPC")
abline(h = 0)
grid()

for (i in seq_len(ncol(bpc_pos))) {
    points(rtime(bpc_pos[, i]), intensity(bpc_pos[, i]), type = "l",
           col = paste0(col_sample_type[bpc_pos$sample_type[i]], 80))
}
for (i in seq_len(ncol(bpc_neg))) {
    points(rtime(bpc_neg[, i]), -intensity(bpc_neg[, i]), type = "l",
           col = paste0(col_sample_type[bpc_neg$sample_type[i]], 80))
}

par(mfrow = c(2, 1))
plot(bpc_pos, col = paste0(col_sample_type[bpc_pos$sample_type], 80))
grid()
legend("topright", col = col_sample_type, lwd = 1,
       legend = names(col_sample_type))
plot(bpc_neg, col = paste0(col_sample_type[bpc_neg$sample_type], 80))
grid()
```

Observations:

RT ranges and spectra number per MS levels:

```{r, eval=FALSE}
#' Range
range(rtime(mse_pos))
range(rtime(mse_neg))

#' Count the number of spectra with a specific MS level per file.
print("Positive mode")
spectra(mse_pos) |>
    msLevel() |>
    split(fromFile(mse_pos)) |>
    lapply(table) |>
    do.call(what = cbind)

#' Count the number of spectra with a specific MS level per file.
print("Negative mode")
spectra(mse_neg) |>
    msLevel() |>
    split(fromFile(mse_neg)) |>
    lapply(table) |>
    do.call(what = cbind)
```

Obervations:

Below decide if want to filter retention time (method dependent), if yes run:

```{r}
# mse <- filterRt(mse, rt = c(0, 60)) ## change c(0,60) to your settings
```

# Estimate peak-picking parameters on ONE file.

```{r, eval=FALSE}
sp_meta <- split(meta_pos, meta_pos$filname)
x_meta <- sp_meta[[1]]
x_mse <- mse_pos[idx_sample_pos][1]
```

## Extract theoretical EICs

Using theoretical m/z for both main positive adducts and all along the
retention time.

```{r, eval=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

#' Calculate m/z from the exact mass
theo_mz <- mass2mz(x_meta[, "M"], c("[M+H]+", "[M+Na]+")) |>
    as.vector()
#' Define the m/z range.
theo_mzr <- cbind(mzmin = theo_mz - MsCoreUtils::ppm(theo_mz, 20),
                  mzmax = theo_mz + MsCoreUtils::ppm(theo_mz, 20))
#' Expand by a fixed tolerance.
theo_mzr[, 1L] <- theo_mzr[, 1L] - 0.005
theo_mzr[, 2L] <- theo_mzr[, 2L] + 0.005
eicsMH <- chromatogram(x_mse, mz = theo_mzr)

#' would use the ID + adduct as file name.
fData(eicsMH)$std_id <- paste0(rep(x_meta$ChEBI, 2), "-", 
                               rep(c("[M+H]+", "[M+Na]+"), each = nrow(x_meta)))
fData(eicsMH)$std_name <- paste0(rep(x_meta$`ChEBI name`, 2), "-", 
                               rep(c("[M+H]+", "[M+Na]+"), each = nrow(x_meta)))
rownames(eicsMH) <- fData(eicsMH)$std_id

dr <- "res/hmgu/eics_full_rt_slices/M_ions/"
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
for (i in seq_along(eicsMH)) {
    png(paste0(dr, "EIC_", fData(eicsMH)$std_id[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    plot(eicsMH[i, ], main = fData(eicsMH)$std_name[i])
    legend("topright",
           legend = c(mzmin = format(fData(eicsMH)$mzmin[i], digits = 6),
                      mzmax = format(fData(eicsMH)$mzmax[i], digits = 6)))
    grid()
    dev.off()
}

```

We have `r length(theo_mz)` number of standard.

## Peak picking param set up

Look at the previously generated EICs to set up parameters. This should happen
only once per lab.

First quickly check a few peaks to look for peak-width:

```{r, eval=FALSE}
## !!! adjust to compounds you see interesting peaks, look for multiple !!!
plot(eicsMH["..."], xlim = c(.., ..)) # how large is the peak ?
plot(eicsMH["..."], xlim = c(.., ..)) # how large is the peak ?
plot(eicsMH["..."], xlim = c(.., ..)) # how large is the peak ?
 
```

Set up a lower and upper boundary of peak-width based on your observation.

```{r}
pw <- c(...,..) ## define here based on the observation above
```

For ppm deviation:

Choose a compound from above and adjust the

```{r, eval=FALSE}
mz <- mz(eicsMH["..."]) |> as.vector() ## choose compound here
cst <- x_mse |>
    spectra() |>
    filterMsLevel(msLevel = 1L) |>
    filterRt(rt = c(25, 27)) |> ## adjust the rt based on the objservation. be VERY restricitive. 
    filterMzRange(mz = mz)

#' Show the number of peaks per m/z filtered spectra
lengths(cst) ### the output here should look a bit like "1 1 1 1 1 " 
```

```{r, eval=FALSE}
#' Calculate the difference in m/z values between scans
mz_diff <- cst |>
    mz() |>
    unlist() |>
    diff() |>
    abs()

#' Express differences in ppm
range(mz_diff * 1e6 / mean(unlist(mz(cst))))
```

Take a number a bit above the output from above. Also depends on the machine.
We try not to go below 10ppm.

```{r}
ppmval <- ... ## input your number here

```

# Peak picking on ALL samples

```{r,eval=FALSE}
cwp <- CentWaveParam(peakwidth = pw,
                     ppm = ppmval,
                     integrate = 2,
                     snthresh = 7, ## lower if your dataset is too noisy. 
                     noise = 100)  ## increase depending on what you estimate you minimum intensity for real signal to be

mse_pos <- findChromPeaks(mse_pos[idx_sample_pos], cwp, 
                          msLevel = 1L, chunkSize = cores_nb)
mse_neg <- findChromPeaks(mse_neg[idx_sample_neg], cwp,
                          msLevel = 1L, chunkSize = cores_nb)

mnpp <- MergeNeighboringPeaksParam(expandRt = max(pw)/2, 
                                   expandMz = 0.0015,
                                   minProp = 0.75)
mse_pos <- refineChromPeaks(mse_pos, mdpp, chunkSize = cores_nb)
print("Positive mode:")
chromPeakData(mse_pos)$merged |>
                         table() 

mse_neg <- refineChromPeaks(mse_neg, mnpp, chunkSize = cores_nb)
print("Negative mode:")
chromPeakData(mse_neg)$merged |>
                      table()
```

# Retention time correction using NAPS

```{r}
sg <- factor(sampleData(mse)$Sample.Name, levels = c("NAPS"))
# Group peaks for NAPS
pdp <- PeakDensityParam(sampleGroups = sg, minFraction = 1,
                        binSize = 0.01, ppm = 10, bw = 2)
mse <- groupChromPeaks(mse, param = pdp)

subset <- which(sampleData(mse)$Sample.Name == "NAPS")
pgp <- PeakGroupsParam(minFraction = 1, extraPeaks = 50, span = 0.5,
                       subsetAdjust = "average", subset = subset)
mse <- adjustRtime(mse, param = pgp)

#' Visualize alignment results
plotAdjustedRtime(mse, peakGroupsPch = 1)
grid()
```

## Identify NAPS peaks

```{r}
naps_info <- read_xlsx("NAPS_info.xlsx", .name_repair = "minimal")
naps_info$mz_pos <- mass2mz(naps_info$`exact mass`, "[M+H]+")[,1]
naps_info$mz_neg <- mass2mz(naps_info$`exact mass`, "[M-H]-")[,1]

## Perform correspondence in NAPS pos and neg 
pdp <- PeakDensityParam(sampleGroups = rep(1, length(naps_pos)),
                          minFraction = 1,
                          binSize = 0.01, ppm = 10,
                          bw = 2)
naps_pos <- groupChromPeaks(naps_pos, param = pdp)

pdp <- PeakDensityParam(sampleGroups = rep(1, length(naps_neg)),
                          minFraction = 1,
                          binSize = 0.01, ppm = 10,
                          bw = 2)
naps_neg <- groupChromPeaks(naps_neg, param = pdp)

mtch <- matchValues(featureDefinitions(naps_pos)[, c("rtmed","mzmed")], naps_info, 
                    MzParam(tolerance = 0, ppm = 5), 
                    mzColname = c("mzmed", "mz_pos"))
mtch <- mtch[whichQuery(mtch)]
mtch
naps_res_pos <- matchedData(mtch) |> data.frame()
naps_res_pos <- naps_res_pos[diff(naps_res_pos$rtmed) > 0,]

## then do the same in NEG 
mtch <- matchValues(featureDefinitions(naps_neg)[, c("rtmed","mzmed")], naps_info, 
                    MzParam(tolerance = 0, ppm = 5), 
                    mzColname = c("mzmed", "mz_neg"))
mtch <- mtch[whichQuery(mtch)]
mtch
naps_res_neg <- matchedData(mtch) |> data.frame()
naps_res_neg <- naps_res_neg[diff(naps_res_neg$rtmed) > 0,]

##Later on can export this as a table i guess. let's see. 
```

# Save results

```{r}
## export object needed for library building
mse <- mse[sampleData(mse)$sample_type == "sample"]
mse_pos <- mse[sampleData(mse)$polarity == "pos"]
mse_neg <- mse[sampleData(mse)$polarity == "neg"]

saveMsObject(mse,
             AlabasterParam(path = file.path("res/", lab, "/objects/mse")))
saveMsObject(mse_pos,
             AlabasterParam(path = file.path("res/", lab, "/objects/mse_pos")))
saveMsObject(mse_neg,
             AlabasterParam(path = file.path("res/", lab, "/objects/mse_neg")))
```
